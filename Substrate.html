<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Substrate</title>
<style>
body { margin: 0; padding: 0; overflow: hidden; background: #fff; }
#canvas, #glowCanvas { display: block; position: absolute; top: 0; left: 0; }
#glowCanvas { pointer-events: none; }
</style>
</head>
<body>
<CANVAS id="canvas"></CANVAS>
<CANVAS id="glowCanvas"></CANVAS>
<script>
// ========== CONFIGURATION ==========
const CONFIG = {
    // Line behavior
    STEP: 0.7,                     // Line speed in pixels per frame
    INITIAL_CRACKS: 3,             // Number of starting lines
    MAX_CRACKS: 100,               // Maximum concurrent lines
    CIRCLE_PERCENT: 40,            // Probability for curved lines in %
    
    // Visual effects
    GRAINS: 64,                    // Number of sand particles per line
    SAND_MODE: 'both',           // 'both' (both sides), 'single' (one side), 'none' (disabled)
    LINE_WIDTH: 1,                 // Width of crack lines
    OLED_MODE: true,               // Black background with bright lines
    
    // Animation timing
    RESET_AFTER_SECONDS: 60,       // Auto-reset timer (0 = disabled)
    FADE_OUT_SECONDS: 3,           // Soft fade duration before reset
    HARD_RESET_EVERY: 3,           // Hard reset after X soft resets (0 = never)
    HARD_FADE_SECONDS: 2,          // Hard fade to black duration
    HARD_FADE_IN_SECONDS: 2,       // Fade in after hard reset duration
    
    // Branching behavior
    BRANCH_MODE: 'perpendicular',  // 'perpendicular' (±90°), 'opposite' (±90°/±180°), 'any' (0-360°)
    
    // Line drift (bending while drawing)
    LINE_DRIFT_ENABLED: false,     // Lines change direction while drawing
    LINE_DRIFT_AMOUNT: 2,          // Max angle change per frame in degrees
    LINE_DRIFT_FREQUENCY: 0.3,     // Drift probability per frame (0-1)
    
    // Sparkler effect
    SPARKLER_ENABLED: true,        // Particle effect at line tips
    SPARK_SPAWN_RATE: 3,           // New sparks per frame
    SPARK_SPEED_MIN: 0.5,          // Minimum spark velocity
    SPARK_SPEED_MAX: 2.5,          // Maximum spark velocity
    SPARK_LIFETIME: 15,            // Spark lifetime in frames
    SPARK_SIZE: 1.3,               // Spark particle size in pixels
    SPARK_GLOW: 2.0,               // Glow radius around sparks
    
    // Mouse interaction
    CLICK_SPAWN_ENABLED: true,     // Spawn line on click
    CURSOR_SPARKS_ENABLED: true,   // Show sparks at cursor position
    CURSOR_SPARK_RATE: 2,          // Cursor sparks per frame
    
    // Normal mode colors
    FG_COLOR: [0, 0, 0],
    BG_COLOR: [255, 255, 255],
    COLORS: [
        [255, 50, 50],    // Bright red
        [50, 255, 50],    // Bright green
        [50, 50, 255],    // Bright blue
        [255, 255, 0],    // Yellow
        [255, 0, 255],    // Magenta
        [0, 255, 255]     // Cyan
    ],
    
    // OLED mode colors (auto-selected when OLED_MODE = true)
    OLED_FG_COLOR: [255, 255, 255],
    OLED_BG_COLOR: [0, 0, 0],
    OLED_COLORS: [
        [0, 255, 255],    // Cyan
        [255, 0, 255],    // Magenta
        [255, 255, 0],    // Yellow
        [0, 255, 128],    // Green-Cyan
        [255, 128, 0],    // Orange
        [128, 0, 255]     // Purple
    ]
};
// ===================================


window.onload = function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    const glowCanvas = document.getElementById('glowCanvas');
    const glowCtx = glowCanvas.getContext('2d', { alpha: true });
    
    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    glowCanvas.width = canvasWidth;
    glowCanvas.height = canvasHeight;
    
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    glowCtx.imageSmoothingEnabled = true;
    glowCtx.imageSmoothingQuality = 'high';

    // Select color scheme
    const FG_COLOR = CONFIG.OLED_MODE ? CONFIG.OLED_FG_COLOR : CONFIG.FG_COLOR;
    const BG_COLOR = CONFIG.OLED_MODE ? CONFIG.OLED_BG_COLOR : CONFIG.BG_COLOR;
    const COLORS = CONFIG.OLED_MODE ? CONFIG.OLED_COLORS : CONFIG.COLORS;
    
    document.body.style.background = `rgb(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]})`;

    // State variables
    let cracks = [];
    let sparks = [];
    let cgrid = new Array(canvasWidth * canvasHeight).fill(10001);  // Collision grid (10001 = empty)
    let nextCrackId = 0;
    let startTime = Date.now();
    let fadingOut = false;
    let fadeStartTime = 0;
    let resetCounter = 0;
    let hardFading = false;
    let fadingIn = false;
    let fadeInStartTime = 0;
    
    // Mouse tracking
    let mouseX = -100;
    let mouseY = -100;
    let mouseInCanvas = false;


    // Collision grid helpers
    function getCGrid(x, y) {
        if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return 10001;
        return cgrid[Math.floor(x) + Math.floor(y) * canvasWidth];
    }

    function setCGrid(x, y, val) {
        if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) return;
        cgrid[Math.floor(x) + Math.floor(y) * canvasWidth] = val;
    }


    // Fade animation helpers
    function getFadeProgress() {
        if (!fadingOut) return 0;
        const elapsed = (Date.now() - fadeStartTime) / 1000;
        const duration = hardFading ? CONFIG.HARD_FADE_SECONDS : CONFIG.FADE_OUT_SECONDS;
        return Math.min(elapsed / duration, 1);
    }

    function getFadeInProgress() {
        if (!fadingIn) return 1;
        const elapsed = (Date.now() - fadeInStartTime) / 1000;
        return Math.min(elapsed / CONFIG.HARD_FADE_IN_SECONDS, 1);
    }


    function reset() {
        cracks = [];
        sparks = [];
        cgrid = new Array(canvasWidth * canvasHeight).fill(10001);
        nextCrackId = 0;
        startTime = Date.now();
        fadingOut = false;
        fadeStartTime = 0;
        hardFading = false;
        
        for (let i = 0; i < CONFIG.INITIAL_CRACKS; i++) makeCrack();
    }


    function startFadeOut() {
        fadingOut = true;
        fadeStartTime = Date.now();
        
        if (CONFIG.HARD_RESET_EVERY > 0 && resetCounter >= CONFIG.HARD_RESET_EVERY - 1) {
            hardFading = true;
        } else {
            hardFading = false;
        }
    }


    function startFadeIn() {
        fadingIn = true;
        fadeInStartTime = Date.now();
    }


    function applyFadeOverlay() {
        const fadeProgress = getFadeProgress();
        
        if (hardFading) {
            // Complete fade to black
            const alpha = 0.06;
            ctx.fillStyle = `rgba(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]},${alpha})`;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            if (fadeProgress >= 1) {
                ctx.fillStyle = `rgb(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                resetCounter = 0;
                reset();
                startFadeIn();
            }
        } else {
            // Soft fade
            const alpha = 0.04;
            ctx.fillStyle = `rgba(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]},${alpha})`;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            if (fadeProgress >= 1) {
                resetCounter++;
                reset();
            }
        }
    }


    function handleResize() {
        const oldWidth = canvasWidth;
        const oldHeight = canvasHeight;
        const oldGrid = cgrid;
        
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        
        // Preserve existing content
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = oldWidth;
        tempCanvas.height = oldHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, 0, 0);
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        glowCanvas.width = canvasWidth;
        glowCanvas.height = canvasHeight;
        
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        glowCtx.imageSmoothingEnabled = true;
        glowCtx.imageSmoothingQuality = 'high';
        
        ctx.fillStyle = `rgb(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Rebuild collision grid
        cgrid = new Array(canvasWidth * canvasHeight).fill(10001);
        const copyWidth = Math.min(oldWidth, canvasWidth);
        const copyHeight = Math.min(oldHeight, canvasHeight);
        
        for (let y = 0; y < copyHeight; y++) {
            for (let x = 0; x < copyWidth; x++) {
                const oldIndex = x + y * oldWidth;
                const newIndex = x + y * canvasWidth;
                cgrid[newIndex] = oldGrid[oldIndex];
            }
        }
    }

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(handleResize, 100);
    });


    // Mouse event handlers
    function handleClick(e) {
        if (!CONFIG.CLICK_SPAWN_ENABLED) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        makeCrack(x, y);
    }
    
    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
        mouseInCanvas = true;
    }
    
    function handleMouseLeave() {
        mouseInCanvas = false;
    }
    
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseleave', handleMouseLeave);
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleClick(touch);
    });
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseMove(touch);
    });


    // Calculate new branch angle based on mode
    function getBranchAngle(baseAngle) {
        let angleOffset;
        
        switch(CONFIG.BRANCH_MODE) {
            case 'perpendicular':
                angleOffset = (Math.random() > 0.5 ? 90 : -90);
                break;
                
            case 'opposite':
                const angles = [90, -90, 180, -180];
                angleOffset = angles[Math.floor(Math.random() * angles.length)];
                break;
                
            case 'any':
                angleOffset = Math.random() * 360;
                return angleOffset + (Math.random() * 4 - 2);
                
            default:
                angleOffset = (Math.random() > 0.5 ? 90 : -90);
        }
        
        return baseAngle + angleOffset + (Math.random() * 4 - 2);
    }


    // Spark particle
    class Spark {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            
            const angle = Math.random() * Math.PI * 2;
            const speed = CONFIG.SPARK_SPEED_MIN + Math.random() * (CONFIG.SPARK_SPEED_MAX - CONFIG.SPARK_SPEED_MIN);
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            
            this.life = CONFIG.SPARK_LIFETIME;
            this.maxLife = CONFIG.SPARK_LIFETIME;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.vy += 0.05;  // Gravity
        }
        
        draw() {
            const fadeMultiplier = fadingIn ? getFadeInProgress() : 1;
            const alpha = (this.life / this.maxLife) * fadeMultiplier;
            
            // Glow effect
            if (CONFIG.SPARK_GLOW > 0) {
                const gradient = glowCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, CONFIG.SPARK_GLOW);
                gradient.addColorStop(0, `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${alpha * 0.3})`);
                gradient.addColorStop(1, `rgba(${this.color[0]},${this.color[1]},${this.color[2]},0)`);
                
                glowCtx.fillStyle = gradient;
                glowCtx.beginPath();
                glowCtx.arc(this.x, this.y, CONFIG.SPARK_GLOW, 0, Math.PI * 2);
                glowCtx.fill();
            }
            
            // Core particle
            glowCtx.fillStyle = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${alpha})`;
            glowCtx.fillRect(Math.floor(this.x), Math.floor(this.y), CONFIG.SPARK_SIZE, CONFIG.SPARK_SIZE);
        }
        
        isDead() {
            return this.life <= 0;
        }
    }


    // Crack line
    class Crack {
        constructor(startX = null, startY = null) {
            this.id = nextCrackId++;
            this.manualStart = (startX !== null && startY !== null);
            this.x = startX !== null ? startX : Math.random() * canvasWidth;
            this.y = startY !== null ? startY : Math.random() * canvasHeight;
            this.t = Math.random() * 360;
            this.curved = false;
            this.degreesDrawn = 0;
            this.sandG = Math.random() * 0.2 - 0.01;
            this.sandP = 0;
            this.sandColor = COLORS[Math.floor(Math.random() * COLORS.length)];
            this.alive = true;
            this.lastX = this.x;
            this.lastY = this.y;
            this.startCrack();
        }
        
        startCrack() {
            let px = Math.floor(this.x);
            let py = Math.floor(this.y);
            
            // Find existing crack to branch from (unless manually placed)
            if (!this.manualStart) {
                let found = false, timeout = 0;
                while (!found && timeout < 1000) {
                    timeout++;
                    px = Math.floor(Math.random() * canvasWidth);
                    py = Math.floor(Math.random() * canvasHeight);
                    if (getCGrid(px, py) < 10000) found = true;
                }
                if (!found) {
                    px = Math.floor(this.x);
                    py = Math.floor(this.y);
                }
            }
            
            const oldA = getCGrid(px, py);
            let a;
            
            if (this.manualStart && oldA > 10000) {
                a = Math.random() * 360;  // Random angle if no existing crack
            } else {
                a = getBranchAngle(oldA);  // Branch from existing crack
            }
            
            // Determine if this will be a curved line
            if (Math.random() * 100 < CONFIG.CIRCLE_PERCENT) {
                this.curved = true;
                this.degreesDrawn = 0;
                let r = 10 + Math.random() * (canvasWidth + canvasHeight) / 2;
                if (Math.random() > 0.5) r = -r;
                const radInc = CONFIG.STEP / r;
                this.tInc = radInc * 180 / Math.PI;
                this.ys = r * Math.sin(radInc);
                this.xs = r * (1 - Math.cos(radInc));
            }
            
            // Set starting position
            if (this.manualStart) {
                this.t = a;
            } else {
                this.x = px + 0.61 * Math.cos(a * Math.PI / 180);
                this.y = py + 0.61 * Math.sin(a * Math.PI / 180);
                this.t = a;
            }
            
            this.lastX = this.x;
            this.lastY = this.y;
        }
        
        drawSandRegion(direction) {
            // Find perpendicular region for sand particles
            let rx = this.x, ry = this.y, openspace = true;
            
            // Direction multiplier for both sides
            const dirMult = direction;
            
            while (openspace) {
                rx += dirMult * 0.81 * Math.sin(this.t * Math.PI / 180);
                ry -= dirMult * 0.81 * Math.cos(this.t * Math.PI / 180);
                const cx = Math.floor(rx), cy = Math.floor(ry);
                if (cx < 0 || cx >= canvasWidth || cy < 0 || cy >= canvasHeight || getCGrid(cx, cy) <= 10000) {
                    openspace = false;
                }
            }
            
            this.sandG += Math.random() * 0.1 - 0.05;
            this.sandG = Math.max(0, Math.min(1, this.sandG));
            const w = this.sandG / (CONFIG.GRAINS - 1);
            
            const fadeMultiplier = fadingIn ? getFadeInProgress() : 1;
            
            // Draw sand particles
            for (let i = 0; i < CONFIG.GRAINS; i++) {
                const drawX = this.x + (rx - this.x) * Math.sin(this.sandP + Math.sin(i * w));
                const drawY = this.y + (ry - this.y) * Math.sin(this.sandP + Math.sin(i * w));
                const baseAlpha = 0.1 - i / (CONFIG.GRAINS * 10);
                const alpha = baseAlpha * fadeMultiplier;
                
                ctx.fillStyle = `rgba(${this.sandColor[0]},${this.sandColor[1]},${this.sandColor[2]},${alpha})`;
                ctx.beginPath();
                ctx.arc(drawX, drawY, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        regionColor() {
            if (CONFIG.SAND_MODE === 'none') return;
            
            if (CONFIG.SAND_MODE === 'both') {
                this.drawSandRegion(1);   // Right side
                this.drawSandRegion(-1);  // Left side
            } else {
                this.drawSandRegion(1);   // Single side only
            }
        }
        
        spawnSparks() {
            if (!CONFIG.SPARKLER_ENABLED) return;
            
            for (let i = 0; i < CONFIG.SPARK_SPAWN_RATE; i++) {
                sparks.push(new Spark(this.x, this.y, this.sandColor));
            }
        }
        
        applyDrift() {
            if (!CONFIG.LINE_DRIFT_ENABLED || this.curved) return;
            
            if (Math.random() < CONFIG.LINE_DRIFT_FREQUENCY) {
                const drift = (Math.random() * 2 - 1) * CONFIG.LINE_DRIFT_AMOUNT;
                this.t += drift;
            }
        }
        
        move() {
            if (!this.alive) return;
            
            this.lastX = this.x;
            this.lastY = this.y;
            
            this.applyDrift();
            
            // Calculate new position
            if (!this.curved) {
                this.x += CONFIG.STEP * Math.cos(this.t * Math.PI / 180);
                this.y += CONFIG.STEP * Math.sin(this.t * Math.PI / 180);
            } else {
                this.x += this.ys * Math.cos(this.t * Math.PI / 180) + this.xs * Math.cos(this.t * Math.PI / 180 - Math.PI / 2);
                this.y += this.ys * Math.sin(this.t * Math.PI / 180) + this.xs * Math.sin(this.t * Math.PI / 180 - Math.PI / 2);
                this.t += this.tInc;
                this.degreesDrawn += Math.abs(this.tInc);
            }
            
            const cx = Math.floor(this.x + Math.random() * 0.33 - 0.165);
            const cy = Math.floor(this.y + Math.random() * 0.33 - 0.165);
            
            if (cx >= 0 && cx < canvasWidth && cy >= 0 && cy < canvasHeight) {
                this.regionColor();
                
                const fadeMultiplier = fadingIn ? getFadeInProgress() : 1;
                
                // Draw line segment
                ctx.strokeStyle = `rgba(${FG_COLOR[0]},${FG_COLOR[1]},${FG_COLOR[2]},${fadeMultiplier})`;
                ctx.lineWidth = CONFIG.LINE_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(this.lastX, this.lastY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();
                
                this.spawnSparks();
                
                // Check termination conditions
                if (this.curved && this.degreesDrawn > 360) {
                    // Curved line completed full circle
                    this.alive = false;
                    if (!fadingOut) {
                        makeCrack(); makeCrack();
                    }
                } else if (getCGrid(cx, cy) > 10000 || Math.abs(getCGrid(cx, cy) - this.t) < 5) {
                    // Free space or parallel crack - continue
                    setCGrid(cx, cy, this.t);
                } else if (Math.abs(getCGrid(cx, cy)) > 2) {
                    // Collision with non-parallel crack - branch
                    this.alive = false;
                    if (!fadingOut) {
                        makeCrack(); makeCrack();
                    }
                }
            } else {
                // Hit canvas boundary - branch
                this.alive = false;
                if (!fadingOut) {
                    makeCrack(); makeCrack();
                }
            }
        }
    }


    function makeCrack(x = null, y = null) {
        if (cracks.length < CONFIG.MAX_CRACKS) cracks.push(new Crack(x, y));
    }
    
    
    function spawnCursorSparks() {
        if (!CONFIG.CURSOR_SPARKS_ENABLED || !mouseInCanvas) return;
        
        for (let i = 0; i < CONFIG.CURSOR_SPARK_RATE; i++) {
            sparks.push(new Spark(mouseX, mouseY, FG_COLOR));
        }
    }


    // Initialize
    ctx.fillStyle = `rgb(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    reset();


    // Main animation loop
    function animate() {
        glowCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        if (fadingOut) {
            applyFadeOverlay();
        }
        
        if (!fadingOut) {
            cracks.forEach(c => c.move());
            
            for (let i = cracks.length - 1; i >= 0; i--) {
                if (!cracks[i].alive) cracks.splice(i, 1);
            }
        }
        
        spawnCursorSparks();
        
        sparks.forEach(s => s.update());
        sparks.forEach(s => s.draw());
        sparks = sparks.filter(s => !s.isDead());
        
        if (fadingIn && getFadeInProgress() >= 1) {
            fadingIn = false;
        }
        
        // Check if reset is needed
        if (!fadingOut && !fadingIn && (cracks.length === 0 || (CONFIG.RESET_AFTER_SECONDS > 0 && (Date.now() - startTime) / 1000 > CONFIG.RESET_AFTER_SECONDS))) {
            if (CONFIG.FADE_OUT_SECONDS > 0) {
                startFadeOut();
            } else {
                ctx.fillStyle = `rgb(${BG_COLOR[0]},${BG_COLOR[1]},${BG_COLOR[2]})`;
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                reset();
            }
        }
        
        requestAnimationFrame(animate);
    }
    animate();
};
</script>
</body>
</html>
